---
title: javascript
---

# 与 After Effects 脚本相关的基础 JavaScript 元素

## JavaScript 变量

脚本共享一个全局环境，因此任何在启动时执行的脚本都可以定义变量和函数，这些变量和函数对所有脚本都可用。在所有情况下，一旦通过运行包含它们的脚本定义了变量和函数，它们就会在给定的 After Effects 会话期间持续存在于后续的脚本中。一旦应用程序退出，所有此类全局定义的变量和函数都会被清除。编写脚本的人应注意为脚本中的变量赋予唯一的名称，以避免无意中重新分配那些旨在整个会话期间保持不变的全局变量。

### 关键字和语句语法

| 关键字/语句 | 描述 |
| --- | --- |
| `break` | 标准 JavaScript；退出当前执行的循环。 |
| `continue` | JavaScript；停止当前循环迭代的执行。 |
| `case` | 在 `switch` 语句中使用的标签。 |
| `default` | 在 `switch` 语句中未找到 `case` 标签时使用的标签。 |
| `do...while` | 标准 JavaScript 结构。类似于 while 循环，不同之处在于循环条件的评估发生在循环的末尾。 |
| `false` | 表示布尔值 false 的字面量。 |
| `for` | 标准 JavaScript 循环结构。 |
| `for...in` | 标准 JavaScript 结构。提供了一种简单的方式来遍历对象的属性。 |
| `function` | 用于定义函数。 |
| `if/if...else` | 标准 JavaScript 条件结构。 |
| `new` | 标准 JavaScript 构造函数语句。 |
| `null` | 分配给变量、数组元素或对象属性，以指示它不包含合法值。 |
| `return` | 标准 JavaScript 从函数返回值或退出函数的方式。 |
| `switch` | 标准 JavaScript 评估 JavaScript 表达式并尝试将表达式的值与 `case` 标签匹配的方式。 |
| `this` | 标准 JavaScript 指示当前对象的方式。 |
| `true` | 表示布尔值 true 的字面量。 |
| `undefined` | 指示变量、数组元素或对象属性尚未被赋值。 |
| `var` | 标准 JavaScript 语法，用于声明局部变量。 |
| `while` | 标准 JavaScript 结构。类似于 do...while 循环，不同之处在于循环条件的评估发生在循环的开始处。 |
| `with` | 标准 JavaScript 结构，用于指定在后续语句中使用的对象。 |

---

## JavaScript 运算符

以下表格列出并描述了 After Effects 脚本引擎识别的所有运算符，并显示了所有运算符的优先级和结合性。

### 运算符描述

| 运算符 | 描述 |
| --- | --- |
| `new` | 创建新的对象实例。 |
| `delete` | 从对象中删除属性。 |
| `typeof` | 返回数据类型。 |
| `void` | 返回未定义的值。 |
| `.` | 对象成员。 |
| `[]` | 数组元素。 |
| `()` | 函数调用。 |
| `++` | 前置或后置递增。 |
| `--` | 前置或后置递减。 |
| `-` | 一元取反或减法。 |
| `~` | 按位取反。 |
| `!` | 逻辑取反。 |
| `*` | 乘法。 |
| `/` | 除法。 |
| `%` | 取模除法。 |
| `+` | 加法。 |
| `<<` | 按位左移。 |
| `>>` | 按位右移。 |
| `>>>` | 无符号按位右移。 |
| `<` | 小于。 |
| `<=` | 小于或等于。 |
| `>` | 大于。 |
| `>=` | 大于或等于。 |
| `==` | 等于。 |
| `!=` | 不等于。 |
| `&` | 按位与。 |
| `^` | 按位异或。 |
| <code>&#124;</code> | 按位或。 |
| `&&` | 逻辑与。 |
| <code>&#124;&#124;</code> | 逻辑或。 |
| `?:` | 条件（三元）运算符。 |
| `=` | 赋值。 |
| `+=` | 加法赋值。 |
| `-=` | 减法赋值。 |
| `*=` | 乘法赋值。 |
| `/=` | 除法赋值。 |
| `%=` | 取模赋值。 |
| `<<=` | 按位左移赋值。 |
| `>>=` | 按位右移赋值。 |
| `>>>=` | 无符号按位右移赋值。 |
| `&=` | 按位与赋值。 |
| `^=` | 按位异或赋值。 |
| <code>&#124;=</code> | 按位或赋值。 |
| `,` | 多重求值。 |

### 运算符优先级

| 运算符（从高到低优先级） | 结合性 |
| --- | --- |
| `[]`, `()`, `.` | 从左到右 |
| `new`, `delete`, `-` (一元取反), `!`, `typeof`, `void`, `++`, `--` | 从右到左 |
| `*`, `/`, `%` | 从左到右 |
| `+`, `-` (减法) | 从左到右 |
| `<<`, `>>`, `>>>` | 从左到右 |
| `<`, `<=`, `>`, `>=` | 从左到右 |
| `==`, `!=` | 从左到右 |
| `&` | 从左到右 |
| `^` | 从左到右 |
| `\` | 从左到右 |
| `&&` | 从左到右 |
| <code>&#124;&#124;</code> | 从左到右 |
| `?:` | 从右到左 |
| `==`, `/=`, `%=`, `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `\=`, `+=`, `-=`, `*=` | 从右到左 |
| `,` | 从左到右 |

---

## JavaScript 类

### 类继承

本节简要介绍面向对象编程和继承。如果你已经了解这些内容，可以跳过本节。

在 JavaScript/Extendscript 中，类继承是指你可以为某个对象定义一些属性或方法，然后创建一个*子类*（或“子类”），该子类继承所有这些属性和方法并添加更多内容，从而进一步细化它。

例如，“汽车”可以是一个基类，而“轿车”是“汽车”基类的一个子类，“轿车”和“敞篷车”是“轿车”基类的两个子类。任何来自“汽车”的属性或方法也可以被“敞篷车”访问，因为存在从“汽车” -> “轿车” -> “敞篷车”的直接继承关系。

### After Effects 中的类继承

作为脚本开发者，了解这一点很有用，因为 After Effects 脚本环境中的许多元素都遵循这种模式。

作为用户，你可以在 After Effects 图层中看到这一点；每个图层都存在于时间轴中，具有名称、索引和标签颜色，但某些类型的图层具有不同的属性——例如，音频图层不能被启用/禁用，而摄像机和灯光图层不能应用效果。它们共享基类“Layer”的特性，但每个都是具有自己属性的**子类**。

同样的概念存在于 After Effects 脚本中。许多 API 可访问的元素都是类层次结构的一部分，这些类继承并细化了属性和方法。这使得 After Effects 开发者能够使用现有结构创建新的 API 可访问组件，并允许脚本开发者使用相同的层次结构来处理 After Effects DOM。

对于上面的例子，[Layer 对象](../../layer/layer)（本身是 [PropertyGroup 对象](../../property/propertygroup) 的子类）是 [AVLayer 对象](../../layer/avlayer)、[CameraLayer 对象](../../layer/cameralayer) 和 [LightLayer 对象](../../layer/lightlayer) 的*基类*。这意味着 CameraLayer 继承了 Layer 对象的所有内容，而 Layer 对象继承了 PropertyGroup 对象的所有内容，PropertyGroup 对象又继承了 PropertyBase 对象的所有内容。

这就是为什么你不会在 Layer 页面上看到 `name` 属性，但你仍然可以在脚本中使用 `layer.name`；`name` 是从 [PropertyBase.name](../../property/propertybase#propertybasename) 继承的。

:::warning
在某些特定情况下，属性和方法在继承时会被**移除**，而不仅仅是添加。这些情况在相关对象页面上有注明。
:::

### 检查类

通常在 JavaScript 中，你可以使用 `instanceof` 来检查任何给定元素是否与预期的对象类型匹配。

请记住，你需要检查*最具体*的类；AE 文本图层只会对 `layer instanceof TextLayer` 返回 `true`，而对所有父类（`layer instanceof AVLayer`、`layer instanceof Layer` 等）返回 `false`。

尽管如此，API 中存在一些元素*仅*作为其他类的基类；它们的存在是为了保存继承的属性和方法，但没有 DOM 元素完全属于这种类型。

当使用这些类检查 `object instanceof {class}` 时，AE 要么会抛出 `{class} is undefined` 的错误，要么返回 `false`，具体取决于类的实现方式。下面的列表记录了哪些仅作为基类的类报告哪种行为。
